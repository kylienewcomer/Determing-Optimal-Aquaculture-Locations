---
title: "EEZs for Aquaculture"
author: "Kylie Newcomer"
date: 11/29/2025
format: pdf
editor: visual
execute: 
  warning: false
  message: false
---

```{r, output = FALSE}
library(tidyverse)
library(sf)
library(terra)
library(here)
library(tmap)
library(kableExtra)

```

## Read in data
```{r, output = FALSE}
sst_08 <- rast(here("data", "average_annual_sst_2008.tif"))

sst_09 <- rast(here("data", "average_annual_sst_2009.tif"))

sst_10 <- rast(here("data", "average_annual_sst_2010.tif"))

sst_11 <- rast(here("data", "average_annual_sst_2011.tif"))

sst_12 <- rast(here("data", "average_annual_sst_2012.tif"))

depth <- rast(here("data", "depth.tif"))

eez <- st_read(here("data", "wc_regions_clean.shp"))

```

## Process data
All temperature rasters from 2008 to 2012 are stacked. The mean of all rasters is taken to determine the average sea surface temperature.
```{r}
all_sst <- c(sst_08,
             sst_09,
             sst_10,
             sst_11,
             sst_12)
```

```{r}
# Rename layers to correspond with years
layer_names <- c("2008", "2009", "2010", "2011", "2012")

names(all_sst) <- layer_names
```

```{r}
# Check names are updated
names(all_sst)
```

```{r}
# Find average across years
mean_sst <- mean(all_sst) - 273.15 # convert from Kelvin to Celsius
```


## Find suitable locations
In order to determine suitable areas of habitat, reclassification matrices are created to assign 1's to areas within the suitable temperature and depth ranges for Oysters. Areas without suitable 
```{r}
# Reclassify temperature data
rcl_temp <- matrix(c(-Inf, 11, 0,
         11, 30, 1,
         30, Inf, 0),
       ncol = 3, byrow = TRUE)


temp_reclass <- classify(mean_sst, rcl = rcl_temp)
```


```{r}
# Reclassify depth data
rcl_depth <- matrix(c(-Inf, -70, 0,
         -70, 0, 1,
         0, Inf, 0),
       ncol = 3, byrow = TRUE)

depth_reclass <- classify(depth, rcl = rcl_depth)

depth_reclass
```

Need to update depth raster to match temperature raster
```{r}
# If-else statement to check/update CRS
if (crs(depth_reclass) == crs(temp_reclass)){
  print("Projections match!")
}else {
  crs(depth_reclass) <- crs(temp_reclass)
  warning("Updating depth CRS")
}
# Match resolutions of rasters
depth_resample <- resample(depth_reclass, temp_reclass, method = "near")

# Match extents of depth and temp rasters
cropped_depth <- crop(depth_resample, temp_reclass)

# Stack temperature and depth rasters
temp_depth <- c(temp_reclass, cropped_depth)

```


```{r}
ocean <- temp_reclass * cropped_depth
```

```{r}
ocean[[1]]
```


# Mapping suitable habitat from combined raster
Remove??
```{r}
# Looking at suitable habitat based on new raster
tm_shape(ocean) +
  tm_graticules() +
  tm_raster(col.scale = tm_scale(
    breaks = c(0,1,Inf),
    values = c("lightblue2", "black"),
    labels = c("Not Suitable", "Suitable")),
    col.legend = tm_legend(
     title = "Suitable habitat",
     position = tm_pos_out("right", "center")
    ))
```

NEED TO REORDER THIS
```{r}
if (crs(eez) == crs(ocean)){
  print("Projections match!")
}else {
  st_crs(eez) <- crs(ocean)
  warning("Updating eez CRS")
}

ocean_mask <- mask(ocean, eez)
```

```{r}
tm_shape(ocean_mask) +
  tm_raster()
```


```{r}
eez_raster <- rasterize(eez, ocean_mask,
                        field = "rgn")



suitable_area <- expanse(ocean_mask, unit = "km", byValue = TRUE, zones = eez_raster)

clean_suitable_area <- suitable_area %>% 
  filter(value == 1) %>%
  select(-layer, -value) %>% 
  rename(rgn = zone)


clean_suitable_area %>% 
  arrange(desc(area)) %>%
  kable(col.names = c("Region", "Area of Suitable Habitat")) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

```
```{r}
suitable_regions <- zonal(ocean_mask, eez_raster, fun = "sum", na.rm = TRUE)

suitable_regions %>% 
  kable(col.names = c("Region", "Number of cells with suitable habitat")) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

suitable_cells <- suitable_regions %>% 
  mutate(cell_area = cell_area$area,
         suitable_habitat = mean * cell_area) %>% 
  select(-cell_area)


```


```{r}
cell_area <- cellSize(ocean_mask, unit="km")[1]
```

```{r}
suitable_cell_area <- suitable_cells %>% 
  mutate(cell_area = cell_area$area,
         suitable_habitat = mean * cell_area) %>% 
  select(-cell_area)

suitable_cell_area %>% 
  arrange(desc(mean)) %>% 
  kable(col.names = c("Region", "Number of cells with suitable habitat", "Area of suitable habitat")) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

```{r}
suitable_habitat <- left_join(eez, clean_suitable_area, by = "rgn")

```



## Must customize this plot...
change colors... look into depth base plot
```{r}
tm_shape(ocean) +                                      
  tm_raster(col.legend = tm_legend(show = FALSE)) +
tm_shape(suitable_habitat) +
  tm_polygons(fill = "area", 
              fill.scale = tm_scale(values =  "viridis"),
                                    #breaks = c(0,200,1000,2500,3000, Inf)),
              fill.legend = tm_legend(title  = "Suitable habitat (sq km)")) + 
  tm_text(text = "rgn",
          col = "white",
          size = 0.35,
          xmod = 4,
          ymod = 1,
          bgcol = "black",
          bgcol_alpha = 0.75)+
tm_grid(alpha = 0.5) +
tm_title("Suitable Aquaculture Zones for Oysters")

```

## Create function
```{r}

aquaculture_zones <- function(species, min_depth, max_depth, min_temp, max_temp){
  # Temp reclassification
  rcl_temp <- matrix(c(-Inf, min_temp, 0,
         min_temp, max_temp, 1,
         max_temp, Inf, 0),
       ncol = 3, byrow = TRUE)
    
  temp_reclass <- classify(mean_sst, rcl = rcl_temp)
  
  # Depth reclassification
  rcl_depth <- matrix(c(-Inf, min_depth, 0,
         min_depth, max_depth, 1,
         max_depth, Inf, 0),
       ncol = 3, byrow = TRUE)
  depth_reclass <- classify(depth, rcl = rcl_depth)

  # Adjust CRS to match
  crs(depth_reclass) <- crs(temp_reclass)
 
  # Match resolutions of rasters
  depth_resample <- resample(depth_reclass, temp_reclass, method = "near")

  # Match extents of depth and temp rasters
  cropped_depth <- crop(depth_resample, temp_reclass)

  # Stack temperature and depth rasters
  #temp_depth <- c(temp_reclass, cropped_depth)
  
  ocean <- cropped_depth * temp_reclass
  
  st_crs(eez) <- crs(ocean)
  
  ocean_mask <- mask(ocean, eez)

  eez_raster <- rasterize(eez, ocean_mask,
                          field = "rgn")



  suitable_area <- expanse(ocean_mask, unit = "km", byValue = TRUE, zones = eez_raster)

  clean_suitable_area <- suitable_area %>% 
    filter(value == 1) %>%
    select(-layer, -value) %>% 
    rename(rgn = zone)
  
  
  suitable_habitat <- left_join(eez, clean_suitable_area, by = "rgn")
  
  tm_shape(ocean) +                                      
    tm_raster(col.legend = tm_legend(show = FALSE)) +
    tm_shape(suitable_habitat) +
    tm_polygons(fill = "area", 
                fill.scale = tm_scale(values =  "viridis"),
                                    #breaks = c(0,200,1000,2500,3000, Inf)),
                fill.legend = tm_legend(title  = "Suitable habitat (sq km)")) + 
    tm_text(text = "rgn",
            col = "white",
            size = 0.35,
            xmod = 4,
            ymod = 1,
            bgcol = "black",
            bgcol_alpha = 0.75)+
    tm_grid(alpha = 0.5) +
    tm_title(paste("Suitable Aquaculture Zones for ", species))

}

aquaculture_zones(species = "oysters", min_depth = -70, max_depth = 0, min_temp =  11, max_temp = 35)
```


Using the function to find suitable aquaculture zones for Red Abalone

Depth range 0-24 m
Temperature range 8-18 C
```{r}
aquaculture_zones(species = "Red Abalone", min_depth = -24, max_depth = 0, min_temp =  8, max_temp = 18)
```
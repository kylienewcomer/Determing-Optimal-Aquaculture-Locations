---
title: "EEZs for Aquaculture"
author: "Kylie Newcomer"
date: 11/29/2025
format: pdf
editor: visual
execute: 
  warning: false
  message: false
---

```{r, output = FALSE}
library(tidyverse)
library(sf)
library(terra)
library(here)
library(tmap)
library(kableExtra)

```

## Read in data
```{r, output = FALSE}
sst_08 <- rast(here("data", "average_annual_sst_2008.tif"))

sst_09 <- rast(here("data", "average_annual_sst_2009.tif"))

sst_10 <- rast(here("data", "average_annual_sst_2010.tif"))

sst_11 <- rast(here("data", "average_annual_sst_2011.tif"))

sst_12 <- rast(here("data", "average_annual_sst_2012.tif"))

depth <- rast(here("data", "depth.tif"))

eez <- st_read(here("data", "wc_regions_clean.shp"))

```

## Process data
#### Combine sst data into single raster
```{r}
all_sst <- c(sst_08,
             sst_09,
             sst_10,
             sst_11,
             sst_12)
```

```{r}
# Rename layers to coorespond with years
layer_names <- c("2008", "2009", "2010", "2011", "2012")

names(all_sst) <- layer_names
```

```{r}
# Check names are updated
names(all_sst)
```

### Find mean sst of 2008-2012
```{r}
# Find average across years
mean_sst <- mean(all_sst) - 273.15 # convert from Kelvin to Celsius
```

```{r}
# Assign land values to NA for aesthetic purposes
depth[depth > 0] <- NA
```


## Find suitable locations

### Create classification matrices
```{r}
# Reclassify temperature data
rcl_temp <- matrix(c(-Inf, 11, 0,
         11, 30, 1,
         30, Inf, 0),
       ncol = 3, byrow = TRUE)


temp_reclass <- classify(mean_sst, rcl = rcl_temp)
```


```{r}
# Reclassify depth data
rcl_depth <- matrix(c(-Inf, -70, 0,
         -70, 0, 1,
         0, Inf, 0),
       ncol = 3, byrow = TRUE)

depth_reclass <- classify(depth, rcl = rcl_depth)

depth_reclass
```

Need to update depth raster to match temperature raster
```{r}
# If-else statement to check/update CRS
if (crs(depth_reclass) == crs(temp_reclass)){
  print("Projections match!")
}else {
  crs(depth_reclass) <- crs(temp_reclass)
  warning("Updating depth CRS")
}

# Match resolutions of rasters
depth_resample <- resample(depth_reclass, temp_reclass, method = "near")

# Match extents of depth and temp rasters
cropped_depth <- crop(depth_resample, temp_reclass)

# Stack temperature and depth rasters
temp_depth <- c(temp_reclass, cropped_depth)

```


```{r}
# Create functino to multiply across layers
mult <- function(mean, depth){
   mean * depth
  }

# Apply function to temp_depth raster
ocean <- lapp(temp_depth[[c(1,2)]],
              fun = mult)
ocean
```
```{r}
ocean[[1]]
```


# Mapping suitable habitat from combined raster
Remove??
```{r}
# Looking at suitable habitat based on new raster
tm_shape(ocean) +
  tm_graticules() +
  tm_raster(col.scale = tm_scale(
    breaks = c(0,1,Inf),
    values = c("lightblue2", "black"),
    labels = c("Not Suitable", "Suitable")),
    col.legend = tm_legend(
     title = "Suitable habitat",
     position = tm_pos_out("right", "center")
    ))
```

NEED TO REORDER THIS
```{r}
ocean_mask <- mask(ocean, eez)

eez_raster <- rasterize(eez, ocean_mask,
                        field = "rgn")

if (crs(eez_raster) == crs(ocean)){
  print("Projections match!")
}else {
  rs(eez_raster) <- crs(ocean)
  warning("Updating eez CRS")
}

suitable_regions <- zonal(ocean_mask, eez_raster, fun = "sum", na.rm = TRUE)

suitable_regions %>% 
  kable(col.names = c("Region", "Number of cells with suitable habitat")) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

```

```{r}
cell_area <- cellSize(ocean_mask, unit="km")[1]
```

```{r}
suitable_cells <- suitable_regions %>% 
  mutate(cell_area = cell_area$area,
         suitable_habitat = lyr1 * cell_area) %>% 
  select(-cell_area)
```

```{r}
suitable_cells %>% 
  kable(col.names = c("Region", "Number of cells with suitable habitat", "Area of suitable habitat")) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

```{r}
eez_suitable <- left_join(eez, suitable_cells, by = "rgn") # Do I need to join this way ?

```



## Must customize this plot...
change colors... look into depth base plot
```{r}
tm_shape(depth) +                                      
  tm_raster(col.legend = tm_legend(show = FALSE)) +
tm_shape(eez_suitable) +                       # Plot EEZ polygons
  tm_polygons(fill = "suitable_habitat", 
              fill.scale = tm_scale(values =  "viridis",
                                    breaks = c(0,200,1000,2500,3000, Inf)),
              fill.legend = tm_legend(title  = "Suitable habitat (sq km)")) + 
  tm_text(text = "rgn",
          col = "white",
          size = 0.35,
          xmod = 7,
          ymod = 1,
          bgcol = "black",
          bgcol_alpha = 0.75)+
tm_grid(alpha = 0.5) +
tm_title("Suitable Aquaculture Zones for Oysters")

```

```{r}
tm_shape(suitable_habitat) +
   tm_raster(col.legend = tm_legend(
     position = tm_pos_out("right", "center")
    ))
```


## Creating function for species...
TBD SPECIES
```{r}

aquaculture_zones <- function(species, min_depth, max_depth, min_temp, max_temp){
  # Temp reclassification
  rcl_temp <- matrix(c(-Inf, 11, 0,
         11, 30, 1,
         30, Inf, 0),
       ncol = 3, byrow = TRUE)
    
  temp_reclass <- classify(mean_sst, rcl = rcl_temp)
  # Depth reclassification
  rcl_depth <- matrix(c(-Inf, -70, 0,
         -70, 0, 1,
         0, Inf, 0),
       ncol = 3, byrow = TRUE)
  depth_reclass <- classify(depth, rcl = rcl_depth)

  # Adjust CRS to match
  crs(depth_reclass) <- crs(temp_reclass)
 
  # Match resolutions of rasters
  depth_resample <- resample(depth_reclass, temp_reclass, method = "near")

  # Match extents of depth and temp rasters
  cropped_depth <- crop(depth_resample, temp_reclass)

  # Stack temperature and depth rasters
  temp_depth <- c(temp_reclass, cropped_depth)
  
  # Create functino to multiply across layers
  mult <- function(mean, depth){
    mean * depth
    }

# Apply function to temp_depth raster
  ocean <- lapp(temp_depth[[c(1,2)]],
                fun = mult)
  ocean_mask <- mask(ocean, eez)

  eez_raster <- rasterize(eez, ocean_mask,
                          field = "rgn")

  crs(eez_raster) <- crs(ocean)


  suitable_regions <- zonal(ocean_mask, eez_raster, fun = "sum", na.rm = TRUE)
  cell_area <- cellSize(ocean_mask, unit="km")[1]
   suitable_cells <- suitable_regions %>% 
    mutate(cell_area = cell_area$area,
          suitable_habitat = lyr1 * cell_area) %>% 
    select(-cell_area)
  
  
  eez_suitable <- left_join(eez, suitable_cells, by = "rgn")
  tm_shape(depth) +                                      
    tm_raster(col.legend = tm_legend(show = FALSE)) +
    tm_shape(eez_suitable) +                       # Plot EEZ polygons
    tm_polygons(fill = "suitable_habitat", 
                fill.scale = tm_scale(values =  "viridis",
                                      breaks = c(0,200,1000,2500,3000, Inf)),
                fill.legend = tm_legend(title  = "Suitable habitat (sq km)")) + 
    tm_text(text = "rgn",
            col = "white",
            size = 0.35,
            xmod = 7,
            ymod = 1,
            bgcol = "black",
            bgcol_alpha = 0.75)+
  tm_grid(alpha = 0.5) +
  tm_title("Suitable Aquaculture Zones for Oysters")

}

aquaculture_zones(oysters, -70, 0, 11, 35)
```


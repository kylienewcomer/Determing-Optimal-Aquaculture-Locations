---
title: "EEZs for Aquaculture"
author: "Kylie Newcomer"
date: 11/29/2025
format: pdf
editor: visual
execute: 
  warning: false
  message: false
---

```{r, output = FALSE}
library(tidyverse)
library(sf)
library(terra)
library(here)
library(tmap)
library(kableExtra)

```

## Read in data
```{r, output = FALSE}
sst_08 <- rast(here("data", "average_annual_sst_2008.tif"))

sst_09 <- rast(here("data", "average_annual_sst_2009.tif"))

sst_10 <- rast(here("data", "average_annual_sst_2010.tif"))

sst_11 <- rast(here("data", "average_annual_sst_2011.tif"))

sst_12 <- rast(here("data", "average_annual_sst_2012.tif"))

depth <- rast(here("data", "depth.tif"))

eez <- st_read(here("data", "wc_regions_clean.shp"))

```

## Process data
All temperature rasters from 2008 to 2012 are stacked. The mean of all temperature rasters is taken to determine the average sea surface temperature. The temperature is converted from Kelvins to degrees celsius.
```{r}
all_sst <- c(sst_08,
             sst_09,
             sst_10,
             sst_11,
             sst_12)
```

```{r}
# Rename layers to correspond with years
layer_names <- c("2008", "2009", "2010", "2011", "2012")

names(all_sst) <- layer_names
```

```{r}
# Check names are updated
names(all_sst)
```

```{r}
# Find average across years
mean_sst <- mean(all_sst) - 273.15 # convert from Kelvin to Celsius
```


## Find suitable locations
In order to determine suitable areas of habitat, reclassification matrices are created to assign 1's to areas within the suitable temperature and depth ranges for Oysters. Areas without suitable depth and temperature ranges get assigned a 0. The CRS, extent, and resolution of the reclassified depth raster are updated to match the reclassified temperature raster. The updated depth and temperature rasters are multiplied together to determine which areas are suitable in both temperature and depth requirements. Any cell with a 1 in both temperature and depth will remain 1, while any cell without suitable depth or temperature ranges, or both, will be 0.
```{r}
# Reclassify temperature data
rcl_temp <- matrix(c(-Inf, 11, 0,
         11, 30, 1,
         30, Inf, 0),
       ncol = 3, byrow = TRUE)


temp_reclass <- classify(mean_sst, rcl = rcl_temp)
```


```{r}
# Reclassify depth data
rcl_depth <- matrix(c(-Inf, -70, 0,
         -70, 0, 1,
         0, Inf, 0),
       ncol = 3, byrow = TRUE)

depth_reclass <- classify(depth, rcl = rcl_depth)

depth_reclass
```

Need to update depth raster to match temperature raster
```{r}
# If-else statement to check/update CRS
if (crs(depth_reclass) == crs(temp_reclass)){
  print("Projections match!")
}else {
  crs(depth_reclass) <- crs(temp_reclass)
  warning("Updating depth CRS")
}
# Match resolutions of rasters
depth_resample <- resample(depth_reclass, temp_reclass, method = "near")

# Match extents of depth and temp rasters
cropped_depth <- crop(depth_resample, temp_reclass)

# Stack temperature and depth rasters
temp_depth <- c(temp_reclass, cropped_depth)

```


```{r}
# Multiply temperature and depth rasters together
ocean <- temp_reclass * cropped_depth
```

```{r}
# Check new raster to make sure multiplcation worked
ocean[[1]]
```


# Mapping suitable habitat from multiplied rasters
```{r}
# Looking at suitable habitat based on new raster
tm_shape(ocean) +
  tm_raster(col.scale = tm_scale(
    breaks = c(0,1,Inf),
    values = c("lightblue2", "black"),
    labels = c("Not Suitable", "Suitable")),
    col.legend = tm_legend(
     title = "Suitable habitat",
     position = tm_pos_out("right", "center")
    )) +
  tm_grid(alpha = 0.4)
```
## Find suitable cells within raster
In order to determine suitable habitat cells within each region of west coast EEZ's, the CRS of the eez data must be updated to match the ocean raster. An ocean raster mask based on the eez data is created to exclude any cells outside of the west coast EEZ's. The eez data is rasterized based on the ocean mask raster to use algebra on the data for finding the total number of suitable cells within each EEZ. The area of an individual cell is calculated and multiplied with the number of cells to determine the area of suitable habitat in each EEZ. The suitable habitat areas are then joined with the eez data map the total area of suitable habitat per region. 
```{r}
# Update CRS eez to match ocean CRS
if (crs(eez) == crs(ocean)){
  print("Projections match!")
}else {
  st_crs(eez) <- crs(ocean)
  warning("Updating eez CRS")
}

# Create mask based on eez values
ocean_mask <- mask(ocean, eez)

eez_raster <- rasterize(eez, ocean_mask,
                        field = "rgn")
```

```{r}
suitable_cells <- zonal(ocean_mask, eez_raster, fun = "sum", na.rm = TRUE)

suitable_cells %>% 
  kable(col.names = c("Region", "Number of cells with suitable habitat")) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

```{r}
# Find the area of individual cell
cell_area <- cellSize(ocean_mask, unit="km")[1]

# Calculate total area of suitable habitat per region
suitable_cell_area <- suitable_cells %>%
  rename(cells = mean) %>%
  mutate(cell_area = cell_area$area,
        suitable_habitat = cells * cell_area) %>% 
  select(-cell_area)

# Table with calculated cells and area per region
suitable_cell_area %>% 
  arrange(desc(cells)) %>% 
  kable(col.names = c("Region", "Number of cells with suitable habitat", "Area of suitable habitat")) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

```{r}
# Join suitable area with west coast eez data
suitable_habitat <- left_join(eez, suitable_cell_area, by = "rgn")
```

# Map suitable area by west coast EEZ's
```{r}
# Map the results
tm_shape(ocean) +                                      
  tm_raster(col.legend = tm_legend(show = FALSE)) +
tm_shape(suitable_habitat) +
  tm_polygons(fill = "suitable_habitat", 
              fill.scale = tm_scale(values =  "viridis"),
                                    #breaks = c(0,200,1000,2500,3000, Inf)),
              fill.legend = tm_legend(title  = "Suitable habitat (sq km)")) + 
  tm_text(text = "rgn", # Add labels for each region
          col = "white",
          size = 0.35,
          xmod = 4,
          ymod = 1,
          bgcol = "black",
          bgcol_alpha = 0.75)+
tm_grid(alpha = 0.5) +
tm_title("Suitable Aquaculture Zones for Oysters")

```

## Create function
```{r}

aquaculture_zones <- function(species, min_depth, max_depth, min_temp, max_temp){
  # Temp reclassification
  rcl_temp <- matrix(c(-Inf, min_temp, 0,
         min_temp, max_temp, 1,
         max_temp, Inf, 0),
       ncol = 3, byrow = TRUE)
    
  temp_reclass <- classify(mean_sst, rcl = rcl_temp)
  
  # Depth reclassification
  rcl_depth <- matrix(c(-Inf, min_depth, 0,
         min_depth, max_depth, 1,
         max_depth, Inf, 0),
       ncol = 3, byrow = TRUE)
  depth_reclass <- classify(depth, rcl = rcl_depth)

  # Adjust CRS to match
  crs(depth_reclass) <- crs(temp_reclass)
 
  # Match resolutions of rasters
  depth_resample <- resample(depth_reclass, temp_reclass, method = "near")

  # Match extents of depth and temp rasters
  cropped_depth <- crop(depth_resample, temp_reclass)

  # Create raster denoting suitable depth AND temperature ranges
  ocean <- cropped_depth * temp_reclass
  
  # Change EEZ CRS
  st_crs(eez) <- crs(ocean)
  
  # Mask ocean data outside of EEZ regions
  ocean_mask <- mask(ocean, eez)

  # Rasterize eez data based on ocean mask
  eez_raster <- rasterize(eez, ocean_mask,
                          field = "rgn")

  # Add up number of suitable cells per region
  suitable_cells <- zonal(ocean_mask, eez_raster, fun = "sum", na.rm = TRUE)

  # Determine cell size
  cell_area <- cellSize(ocean_mask, unit="km")[1]

  # Calulcate area of suiable habitat based on number of suitable cells and cell size
  suitable_cell_area <- suitable_cells %>%
    rename(cells = depth) %>%
    mutate(cell_area = cell_area$area,
          suitable_habitat = cells * cell_area) %>% 
    select(-cell_area)
  
  # Join EEZ regions and suitable area
  suitable_habitat <- left_join(eez, suitable_cell_area, by = "rgn")
  
  # Create map
  tm_shape(ocean) +                                      
    tm_raster(col.legend = tm_legend(show = FALSE)) +
    tm_shape(suitable_habitat) +
    tm_polygons(fill = "suitable_habitat", 
                fill.scale = tm_scale(values =  "viridis"),
                                    #breaks = c(0,200,1000,2500,3000, Inf)),
                fill.legend = tm_legend(title  = "Suitable habitat (sq km)")) + 
    tm_text(text = "rgn",
            col = "white",
            size = 0.35,
            xmod = 4,
            ymod = 1,
            bgcol = "black",
            bgcol_alpha = 0.75)+
    tm_grid(alpha = 0.5) +
    tm_title(paste("Suitable Aquaculture Zones for", species))
}
# Test function with Oysters
aquaculture_zones(species = "Oysters", min_depth = -70, max_depth = 0, min_temp =  11, max_temp = 35)
```

# Use function for new specis of interest
Red Abalone were previously a popular fishery across the west coast, however the fishery closed in 2018 due to declining populations. The only source of Red Abalone on the west coast is currently through aquaculture. Because this species was a popular fishery and still has demand across the west coast, utilizing aquaculture zones along the coast would increase supply for this sought after mollusk. The depth range for Red Abalone is 0-24m and the temperature range is 8-18 ÂºC.
```{r}
aquaculture_zones(species = "Red Abalone", min_depth = -24, max_depth = 0, min_temp =  8, max_temp = 18)
```
These results raise a few flags, because the Washington region has the most suitable habitat, however red Abalone are not native to that



